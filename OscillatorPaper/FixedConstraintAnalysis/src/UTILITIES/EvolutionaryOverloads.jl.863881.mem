        - 
        - import Evolutionary
        - 
        - #< OVERRIDES FOR Evolutionary.jl ##
        - """Custom GA state type that captures additional data from the objective function in the extradata field\n
        -     - `T` is the type of the fitness value\n
        -     - `IT` is the type of the individual\n
        -     - `TT` is the type of the additional data from the objective function\n"""
        - mutable struct CustomGAState <: Evolutionary.AbstractOptimizerState  
        -     N::Int  #* number of elements in an individual
        -     eliteSize::Int  #* number of individuals that are copied to the next generation
        -     fittestValue::Float64  #* fitness of the fittest individual
        -     # fitvals::Vector{Float64}  #* fitness values of the population
        -     fitvals::Matrix{Float64}
        -     fittestInd::Vector{Float64}  #* fittest individual
        -     # periods::Vector{Float64} #* periods of the individuals
        -     # amplitudes::Vector{Float64} #* amplitudes of the individuals
        - end  
        - Evolutionary.value(s::CustomGAState) = s.fittestValue #return the fitness of the fittest individual
        - Evolutionary.minimizer(s::CustomGAState) = s.fittestInd #return the fittest individual
        - 
        - 
        - """Trace override function"""
        - function Evolutionary.trace!(record::Dict{String,Any}, objfun, state, population::Vector{Vector{Float64}}, method::GA, options) 
        0     oscillatory_population_idxs = findall(fit -> fit > 0.0, view(state.fitvals, 1, :)) #find the indices of the oscillatory individuals
        - 
     1008     record["population"] = deepcopy(population[oscillatory_population_idxs])
        0     fitvals = copy(view(state.fitvals,:,oscillatory_population_idxs))
      256     record["fitvals"] = fitvals[1,:]
      256     record["periods"] = fitvals[2,:]
      256     record["amplitudes"] = fitvals[3,:]
        - end
        - 
        - 
        - """Show override function to prevent printing large arrays"""
        - function Evolutionary.show(io::IO, t::Evolutionary.OptimizationTraceRecord)
        -     print(io, lpad("$(t.iteration)",6))
        -     print(io, "   ")
        -     print(io, lpad("$(t.value)",14))
        -     for (key, value) in t.metadata
        -         if !isa(value, AbstractArray)
        -             print(io, "\n * $key: $value")
        -         end
        -     end
        -     print(io, "\n * num_oscillatory: $(length(t.metadata["fitvals"]))")
        -     return
        - end
        - 
        - 
        - """
        -     EvolutionaryObjective(f, x[, F])
        - 
        - Constructor for an objective function object around the function `f` with initial parameter `x`, and objective value `F`.
        - """
        - function Evolutionary.EvolutionaryObjective(f::TC, x::Vector{Float64}, F::Matrix{Float64};
        -                                eval::Symbol = :serial) where {TC}
        -     # @info "Using custom EvolutionaryObjective constructor"
        -     defval = Evolutionary.default_values(x)
        - 
        -     #* convert function into the in-place one
        -     TF = typeof(F)
        - 
  7090784     fn = (Fv,xv) -> (Fv .= f(xv))
        -     TN = typeof(fn)
        -     EvolutionaryObjective{TN,TF,typeof(x),Val{eval}}(fn, F, defval, 0)
        - end
        - 
        - """Override of the multiobjective check"""
        - Evolutionary.ismultiobjective(obj) = false
        - 
        - """Modified value! function from Evolutionary.jl to allow for multiple outputs from the objective function to be stored"""
        - function Evolutionary.value!(obj::EvolutionaryObjective{TC,TF,TX,Val{:thread}},
        -                                 F::AbstractMatrix, xs::AbstractVector{TX}) where {TC,TF,TX}
        -     n = length(xs)
        -     # @info "Evaluating $(n) individuals in parallel"
        -     Threads.@threads for i in 1:n
        -         # @info length(xs[i])
        -         # F[:,i] .= Evolutionary.value(obj, xs[i])  #* evaluate the fitness, period, and amplitude for each individual
        -         fv = view(F, :, i)
        -         # @info length(fv)
        -         value(obj, fv, xs[i])
        -     end
        -     F
        - end
        - 
        - 
        - """Same value! function but with serial eval"""
        - function Evolutionary.value!(obj::EvolutionaryObjective{TC,TF,TX,Val{:serial}},
        -                                 F::AbstractVector, xs::AbstractVector{TX}, P::AbstractVector, A::AbstractVector) where {TC,TF<:AbstractVector,TX}
        -     n = length(xs)
        -     for i in 1:n
        -         F[i], P[i], A[i] = Evolutionary.value(obj, xs[i])  #* evaluate the fitness, period, and amplitude for each individual
        -         # println("Ind: $(xs[i]) fit: $(F[i]) per: $(P[i]) amp: $(A[i])")
        -     end
        -     F, P, A
        - end
        - 
        - """Initialization of my custom GA algorithm state that captures additional data from the objective function\n
        -     - `method` is the GA method\n
        -     - `options` is the options dictionary\n
        -     - `objfun` is the objective function\n
        -     - `population` is the initial population, specifically a Vector for dispatch\n
        -     - `extradata` is the additional data from the objective function\n
        -     - `fittest` is the fittest individual\n"""
        - function Evolutionary.initial_state(method::GA, options, objfun, population::Vector{Vector{Float64}})
        - 
        0     N = length(first(population))
        -     # fitvals = zeros(Float64, method.populationSize)
        -     
        -     # periods = zeros(Float64, method.populationSize)
        -     # amplitudes = zeros(Float64, method.populationSize)
        -     # @info "Initializing GA state"
   240048     output_array = zeros(Float64, 3, method.populationSize)
        - 
        -     #* setup state values
        0     eliteSize = isa(method.ɛ, Int) ? method.ɛ : round(Int, method.ɛ * method.populationSize)
        - 
        -     #* Evaluate population fitness, period and amplitude
        -     # Evolutionary.value!(objfun, fitvals, population, periods, amplitudes)
        0     Evolutionary.value!(objfun, output_array, population)
        - 
        - 
        -     # maxfit, fitidx = findmax(fitvals)
        0     maxfit, fitidx = findmax(view(output_array,1,:))
        - 
        -     #* setup initial state
        -     # return CustomGAState(N, eliteSize, maxfit, fitvals, copy(population[fitidx]), periods, amplitudes)
      208     return CustomGAState(N, eliteSize, maxfit, output_array, copy(population[fitidx]))
        - end
        - 
        - """Modified evaluate! function from Evolutionary.jl to allow for multiple outputs from the objective function to be stored"""
        - # function Evolutionary.evaluate!(objfun, fitvals, population::Vector{Vector{Float64}}, periods, amplitudes, constraints)
        - 
        - #     #* calculate fitness of the population
        - #     Evolutionary.value!(objfun, fitvals, population, periods, amplitudes)
        - 
        - #     #* apply penalty to fitness
        - #     Evolutionary.penalty!(fitvals, constraints, population)
        - # end
        - 
        - function Evolutionary.evaluate!(objfun, fitvals, population::Vector{Vector{Float64}}, constraints)
        - 
        -     #* calculate fitness of the population
        -     Evolutionary.value!(objfun, fitvals, population)
        - 
        -     #* apply penalty to fitness
        -     Evolutionary.penalty!(fitvals, constraints, population)
        - end
        - 
        - """Update state function that captures additional data from the objective function"""
        - function Evolutionary.update_state!(objfun, constraints, state::CustomGAState, parents::Vector{Vector{Float64}}, method::GA, options, itr)
        0     populationSize = method.populationSize
        -     evaltype = options.parallelization
        -     rng = options.rng
   320192     offspring = similar(parents)
        - 
        0     fitness_vals = view(state.fitvals, 1, :)
        - 
        -     #* select offspring
        0     selected = method.selection(fitness_vals, populationSize, rng=rng)
        - 
        -     #* perform mating
        0     offspringSize = populationSize - state.eliteSize
        0     Evolutionary.recombine!(offspring, parents, selected, method, offspringSize, rng=rng)
        - 
        -     #* Elitism (copy population individuals before they pass to the offspring & get mutated)
   320192     fitidxs = sortperm(fitness_vals)
        0     for i in 1:state.eliteSize
        0         subs = offspringSize+i
        0         offspring[subs] = copy(parents[fitidxs[i]])
        0     end
        - 
        -     #* perform mutation
        0     Evolutionary.mutate!(offspring, method, constraints, rng=rng)
        - 
        -     #* calculate fitness and extradata of the population
        -     # Evolutionary.evaluate!(objfun, state.fitvals, offspring, state.periods, state.amplitudes, constraints)
        0     Evolutionary.evaluate!(objfun, state.fitvals, offspring, constraints)
        - 
        - 
        -     #* select the best individual
        0     maxfit, fitidx = findmax(fitness_vals)
        0     state.fittestInd = offspring[fitidx]
        0     state.fittestValue = fitness_vals[fitidx]
        -     
        -     #* replace population
        0     parents .= offspring
        - 
        0     return false
        - end
        - 
        - 
        - 
        - 
